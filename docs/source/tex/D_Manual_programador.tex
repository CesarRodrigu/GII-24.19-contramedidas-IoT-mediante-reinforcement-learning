\apendice{Documentación técnica de programación}

\section{Introducción}

\section{Estructura de directorios}
\label{sec:estructura-directorios}

La estructura de directorios del proyecto que se encuentra en el repositorio de GitHub principalmente consta de los siguientes directorios:
\begin{itemize}
    \item \textbf{app:} Directorio correspondiente al proyecto en Java con Spring Boot 3, que contiene todo el código y lógica de la aplicación web.
    \item \textbf{docs:} Directorio que contiene la documentación general del proyecto, que es donde se encuentra tanto los archivos fuente de LaTeX, como los pdfs de la memoria y el anexo.
    \item \textbf{RL:} Directorio que alberga el código fuente de la parte de Python, que contiene el código del agente de \textit{reinforcement learning} y la implementación sencilla de una API REST para la comunicación entre el agente y la aplicación web.
\end{itemize}
A parte de estas carpetas, en el directorio principal se puede encontrar los siguientes archivos:
\begin{itemize}
    \item \textbf{README.md:} Archivo que contiene una breve descripción del proyecto y las insignias (badges) de la calidad del código, la cobertura y el estado de las \hyperref[subsec:acciones]{acciones de GitHub}.    
    \item \textbf{.gitignore:} Archivo de configuración de Git, que indica los archivos y carpetas deben ser ignorados por el control de versiones.
    \item \textbf{sonar-project.properties:} Archivo de configuración de \hyperref[subsec:sonarqube]{SonarQube}, que contiene la configuración del análisis de calidad del código.
    \item \textbf{docker-compose.yml:} Archivo de configuración de Docker Compose, que permite levantar todos los contenedores necesarios  de Docker para el correcto funcionamiento del proyecto.
    \item \textbf{.env:} Archivo que contiene las variables de entorno necesarias para la ejecución del proyecto. El contenido de este archivo se desarrolla en más detalle en la \hyperref[subsec:politicas]{subsección de Políticas de seguridad}.
\end{itemize}


\section{Manual del programador}
\label{sec:manual-programador}

En la parte de gestión del \href{https://github.com/CesarRodrigu/GII-24.19-contramedidas-IoT-mediante-reinforcement-learning}{repositorio GitHub}, se ha realizado mediante un \href{https://github.com/users/CesarRodrigu/projects/6}{proyecto de GitHub} en el que se ha realizado la gestión de tareas(issues) y la planificación de las mismas, en las que la mayoría se han convertido en ramas de desarrollo para añadir los cambios propuestos.

\subsection{Acciones de GitHub}
\label{subsec:acciones}
Las acciones de GitHub (GitHub Actions) son una herramienta de integración continua y entrega continua (CI/CD) que permite automatizar tareas en el flujo de trabajo de desarrollo de software. En este proyecto se han utilizado para realizar pruebas automáticas del código, pruebas de calidad y la Compilación de la documentación de formato LaTeX a PDF. A continuación se describen las acciones implementadas:
\begin{itemize}
    \item \textbf{Compilación de la documentación:} Se ha creado una acción que compila la documentación del proyecto en formato LaTeX a PDF. Esta acción se ejecuta cada vez que se realiza un push a la rama principal del repositorio en el que se han cambiado los archivos fuente de la propia documentación.
    \item \textbf{SonarQube:} Para las pruebas de calidad de código, se ha implementado SonarQube, que permite analizar el código en busca de errores, vulnerabilidades y problemas de calidad, según las reglas definidas en el proyecto. Cada vez que se añaden cambios a una incorporación de cambios o a la rama principal, se ejecuta una acción que analiza el código, ejecuta los test relacionados para obtener su cobertura y genera un informe de calidad. Este informe se puede consultar en la página de \href{https://sonarcloud.io/project/overview?id=CesarRodrigu_GII-24.19-contramedidas-IoT-mediante-reinforcement-learning}{SonarCloud del proyecto} y también se comenta en la \hyperref[subsec:sonarqube]{subsección dedicada a SonarQube}.

    \item \textbf{CodeQL:} GitHub CodeQL es una herramienta de análisis de código estático que permite detectar vulnerabilidades y errores en el código fuente. Cuando detecta un error suguiere una posible solución mediante Copilot. Esta acción se ejecuta por cada incorporación de cambios al repositorio.
    \item \textbf{Dependabot:} Dependabot es una herramienta de GitHub que ayuda a mantener las dependencias del proyecto actualizadas y seguras, en este caso solo está configurada para que actualice las dependencias si se ha detectado una vulnerabilidad en alguna de ellas. Dependabot crea automáticamente una solicitud de incorporación de cambios para corregirlas, sugiriendo la versión que corrige esa vulnerabilidad.
\end{itemize}

\subsection{Políticas de seguridad}
\label{subsec:politicas}

En el repositorio se ha añadido un conjunto de reglas(ruleset), en el su función es asegurar que todos los cambios se realicen de manera controlada. En la que se ha definido una restricción para que no se pueda realizar un borrado de código no autorizado, y que todos los cambios realizados en el código se realicen mediante una solicitud de incorporación de cambios(pull request), en la que automáticamente realiza una solicitud de revisión de código a copilot y se ejecutan las \hyperref[subsec:acciones]{GitHub Actions ya descritas}.

También hay una opción de poder reportar fallos de seguridad si se han detectado en el código para que se puedan corregir lo más rápidamente posible.
Los escaneos de seguridad que se realizan sobre el código del repositorio principalmente se enfocan en la deteccion de paquetes vulnerables, vulnerabilidades en código y de secretos (credenciales y claves de acceso que no deberían estar en el código fuente).
Cabe destacar que el repositorio tiene en la carpeta raíz un archivo .env que contiene credenciales de acceso a la aplicación y este archivo no se debería de subir al control de versiones. Sin embargo, en este caso se ha subido para que el código funcione correctamente, y que sea más fácil para un tercero ejecutarlo sin problemas, pero en un entorno de producción deberían estar como secretos de GitHub o solo disponer el archivo en el entorno local. Siendo altamente recomendable cambiar las credeciales cuando se vaya a desplegar el código en producción.

\subsection{SonarQube}
\label{subsec:sonarqube}
SonarQube es una herramienta de análisis de código estático que permite detectar errores, vulnerabilidades y problemas de calidad en el código fuente y proporcionar métricas de calidad de software. En el proyecto de \href{https://sonarcloud.io/project/overview?id=CesarRodrigu_GII-24.19-contramedidas-IoT-mediante-reinforcement-learning}{SonarQube} se pueden ver cómo se ha evoluccionado en los problemas de calidad de código, en la cobertura y en las duplicaciones de código. Proporciona una forma muy visual de ver la calidad del código mediante insignias(badges) incluidas en el \href{https://github.com/CesarRodrigu/GII-24.19-contramedidas-IoT-mediante-reinforcement-learning/blob/57-inicio-del-proceso-de-documentaci%C3%B3n-de-la-memoria/README.md}{README} del repositorio.


\section{Compilación, instalación y ejecución del proyecto}
\label{sec:compilacion}


\section{Pruebas del sistema}
\label{sec:pruebas}

Los distintos tipos de pruebas que se han realizado en el proyecto son:
\begin{itemize}
    \item \textbf{Pruebas unitarias:} Se han realizado pruebas unitarias tanto  en el código de Java, Python y JavaScript, utilizando JUnit 5, Pytest y Jest respectivamente. Todas estas pruebas se ejecutan automáticamente cada vez que se realiza un push al repositorio, mediante las \hyperref[subsec:acciones]{GitHub Actions} descritas anteriormente, que envían los resultados a Sonar, pudiendo consultar la cobertura de estas en la \hyperref[subsec:sonarqube]{página de SonarQube}. 
    En el caso de las pruebas unitarias de Java, se han realizado pruebas de integración con la base de datos, utilizando H2 como base de datos en memoria para evitar tener que realizar una conexión a una base de datos real. En el caso del agente de \textit{reinforcement learning}, se han realizado pruebas unitarias para comprobar que los componentes del agente y entorno funcionan correctamente.
    \item \textbf{Pruebas funcionales:} Se han realizado pruebas funcionales a través de Selenium, que permite, a traves de Selenium IDE, grabar pruebas simulando la interacción del usuario con la web. Gracias a la función de exportación de Salenium IDE las pruebas se pueden ejecutar tanto cargando el archivo WebTests.side, como ejecutando las pruebas  de Java (una vez ya iniciada la web) con un perfil de Spring Boot distinto a 'coverage', aceptando el perfil nativo.
\end{itemize}
% #TODO añadir las pruebas de PostMan